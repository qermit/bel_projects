--! @file        prio_auto.vhd
--  DesignUnit   prio_auto
--! @author      M. Kreider <m.kreider@gsi.de>
--! @date        23/06/2016
--! @version     0.0.1
--! @copyright   2016 GSI Helmholtz Centre for Heavy Ion Research GmbH
--!

--! @brief AUTOGENERATED WISHBONE-SLAVE CORE FOR prio.vhd
--!
--------------------------------------------------------------------------------
--! This library is free software; you can redistribute it and/or
--! modify it under the terms of the GNU Lesser General Public
--! License as published by the Free Software Foundation; either
--! version 3 of the License, or (at your option) any later version.
--!
--! This library is distributed in the hope that it will be useful,
--! but WITHOUT ANY WARRANTY; without even the implied warranty of
--! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
--! Lesser General Public License for more details.
--!
--! You should have received a copy of the GNU Lesser General Public
--! License along with this library. If not, see <http://www.gnu.org/licenses/>.
--------------------------------------------------------------------------------

-- ***********************************************************
-- ** WARNING - THIS IS AUTO-GENERATED CODE! DO NOT MODIFY! **
-- ***********************************************************
--
-- If you want to change the interface,
-- modify prio.xml and re-run 'python wbgenplus.py prio.xml' !

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.wishbone_pkg.all;
use work.wbgenplus_pkg.all;
use work.genram_pkg.all;
use work.prio_auto_pkg.all;

entity prio_auto is
generic(
  g_channels  : natural := 16 --Input channels
);
Port(
  clk_sys_i       : std_logic;                                    -- Clock input for sys domain
  rst_sys_n_i     : std_logic;                                    -- Reset input (active low) for sys domain
  cnt_late_i      : in  std_logic_vector(32-1 downto 0);          -- Sum of all late messages
  cnt_late_V_i    : in  std_logic_vector(1-1 downto 0);           -- Valid flag - cnt_late
  cnt_out_all_i   : in  std_logic_vector(64-1 downto 0);          -- Sum of all outgoing messages
  cnt_out_all_V_i : in  std_logic_vector(1-1 downto 0);           -- Valid flag - cnt_out_all
  error_i         : in  std_logic_vector(1-1 downto 0);           -- Error control
  st_full_i       : in  std_logic_vector(g_channels-1 downto 0);  -- Channel Full flag (n..0) 
  st_full_V_i     : in  std_logic_vector(1-1 downto 0);           -- Valid flag - st_full
  st_late_i       : in  std_logic_vector(1-1 downto 0);           -- Late message detected
  st_late_V_i     : in  std_logic_vector(1-1 downto 0);           -- Valid flag - st_late
  stall_i         : in  std_logic_vector(1-1 downto 0);           -- flow control
  ts_late_i       : in  std_logic_vector(64-1 downto 0);          -- First late Timestamp
  ts_late_V_i     : in  std_logic_vector(1-1 downto 0);           -- Valid flag - ts_late
  clear_o         : out std_logic_vector(1-1 downto 0);           -- Clears counters and status
  ebm_adr_o       : out std_logic_vector(32-1 downto 0);          -- Etherbone Master address
  eca_adr_o       : out std_logic_vector(32-1 downto 0);          -- Event Condition Action Unit address
  mode_o          : out std_logic_vector(3-1 downto 0);           -- b2: Time limit, b1: Msg limit, b0 enable
  offs_late_o     : out std_logic_vector(64-1 downto 0);          -- Time offset before message is late
  reset_o         : out std_logic_vector(1-1 downto 0);           -- Resets the Priority Queue
  tx_max_msgs_o   : out std_logic_vector(8-1 downto 0);           -- Max msgs per packet
  tx_max_wait_o   : out std_logic_vector(32-1 downto 0);          -- Max wait time for non empty packet
  tx_rate_limit_o : out std_logic_vector(32-1 downto 0);          -- Max msgs per milliseconds
  
  ctrl_i          : in  t_wishbone_slave_in;
  ctrl_o          : out t_wishbone_slave_out

  
);
end prio_auto;

architecture rtl of prio_auto is

  signal s_pop, s_push      : std_logic;
  signal s_empty, s_full    : std_logic;
  signal r_e_wait, s_e_p    : std_logic;
  signal s_stall            : std_logic;
  signal s_valid,
         s_valid_ok,
         r_valid_check      : std_logic;
  signal r_ack              : std_logic;
  signal r_err              : std_logic;
  signal s_e, r_e, s_w      : std_logic;
  signal s_d                : std_logic_vector(32-1 downto 0);
  signal s_s                : std_logic_vector(4-1 downto 0);
  signal s_a                : std_logic_vector(5-1 downto 0);
  signal s_a_ext,
         r_a_ext0,
         r_a_ext1           : std_logic_vector(7-1 downto 0);
  signal r_error            : std_logic_vector(1-1 downto 0)          := std_logic_vector(to_unsigned(0, 1)); -- Error
  signal s_error_i          : std_logic_vector(1-1 downto 0)          := (others => '0');                     -- Error control
  signal s_stall_i          : std_logic_vector(1-1 downto 0)          := (others => '0');                     -- flow control
  signal r_reset            : std_logic_vector(1-1 downto 0)          := (others => '0');                     -- Resets the Priority Queue
  signal r_mode             : std_logic_vector(3-1 downto 0)          := (others => '0');                     -- b2: Time limit, b1: Msg limit, b0 enable
  signal r_clear            : std_logic_vector(1-1 downto 0)          := (others => '0');                     -- Clears counters and status
  signal r_st_full_V        : std_logic_vector(1-1 downto 0)          := (others => '0');                     -- Valid flag - st_full
  signal s_st_full_V_i      : std_logic_vector(1-1 downto 0)          := (others => '0');                     -- Valid flag - st_full
  signal r_st_full          : std_logic_vector(g_channels-1 downto 0) := (others => '0');                     -- Channel Full flag (n..0) 
  signal s_st_full_i        : std_logic_vector(g_channels-1 downto 0) := (others => '0');                     -- Channel Full flag (n..0) 
  signal r_st_late_V        : std_logic_vector(1-1 downto 0)          := (others => '0');                     -- Valid flag - st_late
  signal s_st_late_V_i      : std_logic_vector(1-1 downto 0)          := (others => '0');                     -- Valid flag - st_late
  signal r_st_late          : std_logic_vector(1-1 downto 0)          := (others => '0');                     -- Late message detected
  signal s_st_late_i        : std_logic_vector(1-1 downto 0)          := (others => '0');                     -- Late message detected
  signal r_ebm_adr          : std_logic_vector(32-1 downto 0)         := (others => '0');                     -- Etherbone Master address
  signal r_eca_adr          : std_logic_vector(32-1 downto 0)         := (others => '0');                     -- Event Condition Action Unit address
  signal r_tx_max_msgs      : std_logic_vector(8-1 downto 0)          := (others => '0');                     -- Max msgs per packet
  signal r_tx_max_wait      : std_logic_vector(32-1 downto 0)         := (others => '0');                     -- Max wait time for non empty packet
  signal r_tx_rate_limit    : std_logic_vector(32-1 downto 0)         := (others => '0');                     -- Max msgs per milliseconds
  signal r_offs_late        : std_logic_vector(64-1 downto 0)         := (others => '0');                     -- Time offset before message is late
  signal r_cnt_late_V       : std_logic_vector(1-1 downto 0)          := (others => '0');                     -- Valid flag - cnt_late
  signal s_cnt_late_V_i     : std_logic_vector(1-1 downto 0)          := (others => '0');                     -- Valid flag - cnt_late
  signal r_cnt_late         : std_logic_vector(32-1 downto 0)         := (others => '0');                     -- Sum of all late messages
  signal s_cnt_late_i       : std_logic_vector(32-1 downto 0)         := (others => '0');                     -- Sum of all late messages
  signal r_ts_late_V        : std_logic_vector(1-1 downto 0)          := (others => '0');                     -- Valid flag - ts_late
  signal s_ts_late_V_i      : std_logic_vector(1-1 downto 0)          := (others => '0');                     -- Valid flag - ts_late
  signal r_ts_late          : std_logic_vector(64-1 downto 0)         := (others => '0');                     -- First late Timestamp
  signal s_ts_late_i        : std_logic_vector(64-1 downto 0)         := (others => '0');                     -- First late Timestamp
  signal r_cnt_out_all_V    : std_logic_vector(1-1 downto 0)          := (others => '0');                     -- Valid flag - cnt_out_all
  signal s_cnt_out_all_V_i  : std_logic_vector(1-1 downto 0)          := (others => '0');                     -- Valid flag - cnt_out_all
  signal r_cnt_out_all      : std_logic_vector(64-1 downto 0)         := (others => '0');                     -- Sum of all outgoing messages
  signal s_cnt_out_all_i    : std_logic_vector(64-1 downto 0)         := (others => '0');                     -- Sum of all outgoing messages


begin

  sp : wb_skidpad
  generic map(
    g_adrbits   => 5
  )
  Port map(
    clk_i        => clk_sys_i,
    rst_n_i      => rst_sys_n_i,
    push_i       => s_push,
    pop_i        => s_pop,
    full_o       => s_full,
    empty_o      => s_empty,
    adr_i        => ctrl_i.adr(6 downto 2),
    dat_i        => ctrl_i.dat,
    sel_i        => ctrl_i.sel,
    we_i         => ctrl_i.we,
    adr_o        => s_a,
    dat_o        => s_d,
    sel_o        => s_s,
    we_o         => s_w
  );

  validmux: with to_integer(unsigned(s_a_ext)) select
  s_valid <= 
  s_st_full_V_i(0)      when c_st_full_GET,       -- 
  s_st_late_V_i(0)      when c_st_late_GET,       -- 
  s_cnt_late_V_i(0)     when c_cnt_late_GET,      -- 
  s_ts_late_V_i(0)      when c_ts_late_GET_0,     -- 
  s_ts_late_V_i(0)      when c_ts_late_GET_1,     -- 
  s_cnt_out_all_V_i(0)  when c_cnt_out_all_GET_0, -- 
  s_cnt_out_all_V_i(0)  when c_cnt_out_all_GET_1, -- 
  '1'                   when others;
  
  s_valid_ok      <=  r_valid_check and s_valid;
  s_e_p           <=  r_e or r_e_wait;
  s_a_ext         <= s_a & "00";
  s_stall         <= s_full;
  s_push          <= ctrl_i.cyc and ctrl_i.stb and not s_stall;
  s_e             <= not (s_empty or s_e_p);
  s_pop           <= s_valid_ok;
  ctrl_o.stall    <= s_stall;
  
  s_error_i         <= error_i;
  s_stall_i         <= stall_i;
  reset_o           <= r_reset;
  mode_o            <= r_mode;
  clear_o           <= r_clear;
  s_st_full_V_i     <= st_full_V_i;
  s_st_full_i       <= st_full_i;
  s_st_late_V_i     <= st_late_V_i;
  s_st_late_i       <= st_late_i;
  ebm_adr_o         <= r_ebm_adr;
  eca_adr_o         <= r_eca_adr;
  tx_max_msgs_o     <= r_tx_max_msgs;
  tx_max_wait_o     <= r_tx_max_wait;
  tx_rate_limit_o   <= r_tx_rate_limit;
  offs_late_o       <= r_offs_late;
  s_cnt_late_V_i    <= cnt_late_V_i;
  s_cnt_late_i      <= cnt_late_i;
  s_ts_late_V_i     <= ts_late_V_i;
  s_ts_late_i       <= ts_late_i;
  s_cnt_out_all_V_i <= cnt_out_all_V_i;
  s_cnt_out_all_i   <= cnt_out_all_i;
  
  ctrl : process(clk_sys_i)
  begin
    if rising_edge(clk_sys_i) then
      if(rst_sys_n_i = '0') then
        r_e           <= '0';
        r_e_wait      <= '0';
        r_valid_check <= '0';
        r_error         <= std_logic_vector(to_unsigned(0, 1));
        r_reset         <= (others => '0');
        r_mode          <= (others => '0');
        r_clear         <= (others => '0');
        r_st_full       <= (others => '0');
        r_st_late       <= (others => '0');
        r_ebm_adr       <= (others => '0');
        r_eca_adr       <= (others => '0');
        r_tx_max_msgs   <= (others => '0');
        r_tx_max_wait   <= (others => '0');
        r_tx_rate_limit <= (others => '0');
        r_offs_late     <= (others => '0');
        r_cnt_late      <= (others => '0');
        r_ts_late       <= (others => '0');
        r_cnt_out_all   <= (others => '0');
      else
        r_e           <= s_e;
        r_a_ext0      <= s_a_ext;
        r_a_ext1      <= r_a_ext0;
        r_e_wait      <= s_e_p and not s_valid_ok;
        r_valid_check <= (r_valid_check or (s_e_p and not stall_i(0))) and not s_valid_ok;
        r_ack         <= s_pop and not (error_i(0) or r_error(0));
        r_err         <= s_pop and     (error_i(0) or r_error(0));
        ctrl_o.ack    <= r_ack;
        ctrl_o.err    <= r_err;
        
        
        if stall_i = "0" then
          r_clear <= (others => '0');
          r_error <= (others => '0');
          r_reset <= (others => '0');
        end if;
        
        if s_cnt_late_V_i     = "1" then r_cnt_late     <= s_cnt_late_i; end if;    -- 
        if s_cnt_out_all_V_i  = "1" then r_cnt_out_all  <= s_cnt_out_all_i; end if; -- 
        if s_st_full_V_i      = "1" then r_st_full      <= s_st_full_i; end if;     -- 
        if s_st_late_V_i      = "1" then r_st_late      <= s_st_late_i; end if;     -- 
        if s_ts_late_V_i      = "1" then r_ts_late      <= s_ts_late_i; end if;     -- 
        
        
        if(s_e = '1') then
          if(s_w = '1') then
            -- WISHBONE WRITE ACTIONS
            case to_integer(unsigned(s_a_ext)) is
              when c_reset_OWR        => r_reset                    <= f_wb_wr(r_reset, s_d, s_s, "owr");                   -- 
              when c_mode_CLR         => r_mode                     <= f_wb_wr(r_mode, s_d, s_s, "clr");                    -- 
              when c_mode_SET         => r_mode                     <= f_wb_wr(r_mode, s_d, s_s, "set");                    -- 
              when c_clear_OWR        => r_clear                    <= f_wb_wr(r_clear, s_d, s_s, "owr");                   -- 
              when c_ebm_adr_RW       => r_ebm_adr                  <= f_wb_wr(r_ebm_adr, s_d, s_s, "owr");                 -- 
              when c_eca_adr_RW       => r_eca_adr                  <= f_wb_wr(r_eca_adr, s_d, s_s, "owr");                 -- 
              when c_tx_max_msgs_RW   => r_tx_max_msgs              <= f_wb_wr(r_tx_max_msgs, s_d, s_s, "owr");             -- 
              when c_tx_max_wait_RW   => r_tx_max_wait              <= f_wb_wr(r_tx_max_wait, s_d, s_s, "owr");             -- 
              when c_tx_rate_limit_RW => r_tx_rate_limit            <= f_wb_wr(r_tx_rate_limit, s_d, s_s, "owr");           -- 
              when c_offs_late_RW_0   => r_offs_late(31 downto 0)   <= f_wb_wr(r_offs_late(31 downto 0), s_d, s_s, "owr");  -- 
              when c_offs_late_RW_1   => r_offs_late(63 downto 32)  <= f_wb_wr(r_offs_late(63 downto 32), s_d, s_s, "owr"); -- 
              when others             => r_error                    <= "1";
            end case;
          else
            -- WISHBONE READ ACTIONS
            case to_integer(unsigned(s_a_ext)) is
              when c_mode_GET           => null;
              when c_st_full_GET        => null;
              when c_st_late_GET        => null;
              when c_ebm_adr_RW         => null;
              when c_eca_adr_RW         => null;
              when c_tx_max_msgs_RW     => null;
              when c_tx_max_wait_RW     => null;
              when c_tx_rate_limit_RW   => null;
              when c_offs_late_RW_0     => null;
              when c_offs_late_RW_1     => null;
              when c_cnt_late_GET       => null;
              when c_ts_late_GET_0      => null;
              when c_ts_late_GET_1      => null;
              when c_cnt_out_all_GET_0  => null;
              when c_cnt_out_all_GET_1  => null;
              when others               => r_error <= "1";
            end case;
          end if; -- s_w
        end if; -- s_e
        
        case to_integer(unsigned(r_a_ext1)) is
          when c_mode_GET           => ctrl_o.dat <= std_logic_vector(resize(unsigned(r_mode), ctrl_o.dat'length));                       -- 
          when c_st_full_GET        => ctrl_o.dat <= std_logic_vector(resize(unsigned(r_st_full), ctrl_o.dat'length));                    -- 
          when c_st_late_GET        => ctrl_o.dat <= std_logic_vector(resize(unsigned(r_st_late), ctrl_o.dat'length));                    -- 
          when c_ebm_adr_RW         => ctrl_o.dat <= std_logic_vector(resize(unsigned(r_ebm_adr), ctrl_o.dat'length));                    -- 
          when c_eca_adr_RW         => ctrl_o.dat <= std_logic_vector(resize(unsigned(r_eca_adr), ctrl_o.dat'length));                    -- 
          when c_tx_max_msgs_RW     => ctrl_o.dat <= std_logic_vector(resize(unsigned(r_tx_max_msgs), ctrl_o.dat'length));                -- 
          when c_tx_max_wait_RW     => ctrl_o.dat <= std_logic_vector(resize(unsigned(r_tx_max_wait), ctrl_o.dat'length));                -- 
          when c_tx_rate_limit_RW   => ctrl_o.dat <= std_logic_vector(resize(unsigned(r_tx_rate_limit), ctrl_o.dat'length));              -- 
          when c_offs_late_RW_0     => ctrl_o.dat <= std_logic_vector(resize(unsigned(r_offs_late(31 downto 0)), ctrl_o.dat'length));     -- 
          when c_offs_late_RW_1     => ctrl_o.dat <= std_logic_vector(resize(unsigned(r_offs_late(63 downto 32)), ctrl_o.dat'length));    -- 
          when c_cnt_late_GET       => ctrl_o.dat <= std_logic_vector(resize(unsigned(r_cnt_late), ctrl_o.dat'length));                   -- 
          when c_ts_late_GET_0      => ctrl_o.dat <= std_logic_vector(resize(unsigned(r_ts_late(31 downto 0)), ctrl_o.dat'length));       -- 
          when c_ts_late_GET_1      => ctrl_o.dat <= std_logic_vector(resize(unsigned(r_ts_late(63 downto 32)), ctrl_o.dat'length));      -- 
          when c_cnt_out_all_GET_0  => ctrl_o.dat <= std_logic_vector(resize(unsigned(r_cnt_out_all(31 downto 0)), ctrl_o.dat'length));   -- 
          when c_cnt_out_all_GET_1  => ctrl_o.dat <= std_logic_vector(resize(unsigned(r_cnt_out_all(63 downto 32)), ctrl_o.dat'length));  -- 
          when others               => ctrl_o.dat <= (others => 'X');
        end case;

        
      end if; -- rst
    end if; -- clk edge
  end process;

end rtl;
